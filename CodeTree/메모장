######################################################################################
- int는 -2^31 ~ 2^31-1까지.
- double은 과학적 표기(ex. 1.5e2, 2.5e-3)가 가능하여 매우 큰 수나 매우 작은 수 표현 가능.
- 연산 과정에서 오차 발생할 수 있어 사용시 주의 필요.
- `/`는 정수 / 정수일 경우 몫만, 하나 이상이 실수형이라면 소수점까지 표현한다.
######################################################################################
- cin 함수는 '공백', '탭', '줄바꿈' 문자를 기준으로 구분해서 하나씩 입력받는 함수이다.
- cout << (int)(a >= b) << '\n'에서 (int)를 쓰지 않아도 정수형(0, 1)으로 출력된다.
| 표현     | 타입              | 용도        |
| ------ | --------------- | --------- |
| `'i'`  | `char`          | 문자 1개     |
| `"i"`  | `const char[2]` | 문자열       |
| `s[i]` | `char`          | 문자열의 한 글자 |
######################################################################################
- char answer = (a == 1) ? 't' : 'f'
- cout << (a == 1) ? 't' : 'f'
연산자 우선순위에서 <<가 우선이므로 t나 f가 아니라 0, 1이 출력된다.
- int arr[4][4]; -> 초기화되지 않음.
- int arr[4][4] = {}; -> 전부 0으로 초기화됨.
######################################################################################
- #include <cctype> : tolower(), toupper(), isupper(), islower(), isalpha(), isdigit()
- <string>에서 stoi(), stod(), ... -> 정수형 string을 정수로 바꿔준다.
- <string>에서 정수를 문자열로 변환하기 위해서는 to_string(인자)을 쓴다.
- 문자열에 대해 >, < 와 같은 대수 비교를 하면 사전 순으로 비교한다. 사전 순서상 먼저 오는 값이 더 작다. ex) a < b ... true, aab < abc ... true
######################################################################################
[시간복잡도]
- 보통 for loop을 1억번 돌 때 1초가 걸린다.
- 따라서 제한 시간이 1초인 경우라면
    - N <= 10 : O(N!), O(2^N), O(3^N)
    - N <= 100 : O(N^4)
    - N <= 500 : O(N^3)
    - N <= 1,000 : O(N^2), O(N^2*logN)
    - N <= 100,000 : O(N), O(NlogN), O(logN), O(1)
[공간복잡도]
- int : 4byte
- double : 8 byte
- char : 1 byte
- short : 2 byte
    - int a[2천만] = 80MB
    - int a[2백만] = 8MB
    - char a[2천만] = 20MB
    - double a[2천만] = 160MB
######################################################################################
[Pointer]
- 변수를 Call by Ref로 취급하기 위해서는 &를 활용한다.
- 배열을 Call by Ref로 취급하기 위해서는 *를 활용한다.
######################################################################################
[Var Scope]
- global 변수의 중요한 특징 중 하나는 "자동으로 초기값이 0으로 정해진다"는 것이다.
- 배열을 선언하면 배열 내 모든 값들이 0으로 채워지고, 변수의 경우에는 0이 들어가게 된다.
######################################################################################
[Recursion]
6543

- f(6543) -> f(654) + f(3)
- f(654) -> f(65) + f(4)
- f(65) -> f(6) + f(5)
- f(6) = 36, f(5) = 25 -> f(65) = 61
f(4) = 16 -> f(654) = 77
f(3) = 9 -> f(6543) = 86

230
f(230) : f(115) + 1
f(115) : f(38) + 1
f(38) : f(19) + 1
f(19) : f(6) + 1
f(6) : f(3) + 1
f(3) : f(1) + 1
= 1 + 1 + 1 + 1 + 1 + 1 + 1

f(6) : f(5) + f(4) = f(4) + f(3) + f(3) + f(2) = f(3) + f(2) + f(2) + f(1) + f(2) + f(1) + 1 = f(2) + f(1) + f(2) + f(2) + f(1) + f(2) + f(1) + 1 = 8
f(5) : f(4) + f(3) = 3 + f(2) + f(1) = 3 + 1 + 1 = 5
f(4) : f(3) + f(2) = 2 + 1 = 3
f(3) : f(2) + f(1) = 1 + 1 = 2

f(8 ,4) : f7, f6, f5
f7 : f6, f5, f4(4)		f6 : f5 f4(4) f3(3)		f5 : f4(4)
f6 : f5 f4(4) f3(3)		f5 : f4(4) f3(3) f2(2)	f4 : f3(3) f2(2) f1(1)	|	f5 : f4(4) f3(3) f2(2)
f5 : f4(4) f3(3) f2(2)

f2 = 2 f3 = 3 f4 = 4 f5 = 9 f6 = 16 f7 = 29 f8 = 54

// 점화식 : f(n) = f(n + 1) + f(n + 3) + 1
int p[10] = {1, 3, 7, 8, 4, 3, 5, 2, 9, 2}; 
f(0, 9, 5, 6) : mid(4) / lc(3) / -> f(5, 9, 5, 3)
f(5, 9, 5, 3) : mid(7) / lc(3) / -> f(5, 7, 5, 3)
f(5, 7, 5, 3) : mid(6) / lc(2) / -> f(7, 7, 5, 1)
f(7, 7, 5, 1) : return p[7] : 2

f4 : f5 + f7 + 1 = 23
f5 : f6 + f8 + 1 = 16 / f7 : f8 + 0 + 1 = 6
f6 : f7 + f9 + 1 = 10 / f8 : f9 + 1 + 1 = 5 / f8 : f9 + 1 + 1 = 5
f7 : f8 + 0 + 1 = 6 / f9 : 0 + 2 + 1 = 3 / f9 : 0 + 2 + 1 = 3 / f9 : 0 + 2 + 1 = 3
f8 : f9 + 1 + 1 = 5
f9 : 0 + 2 + 1 = 3
######################################################################################
[구간, 지점]
- 구간인 경우 x1 ~ x2 - 1
- 지점인 경우 x1 ~ x2
######################################################################################
[dx, dy Technique]
- 시계 방향 90도 회전
int dir_num = 3; 
int x = 1, y = 5;
int dx[4] = {1, 0, -1, 0};  // 회전 방향에 맞춰 dx 설정
int dy[4] = {0, -1, 0, 1};  // 회전 방향에 맞춰 dy 설정
int nx, ny;

// rotate direction
dir_num = (dir_num + 1) % 4;

// move
nx = x + dx[dir_num], ny = y + dy[dir_num];

- 반시계 방향 90도 회전
dir_num = (dir_num - 1 + 4) % 4;

- 반대 방향으로 전환하는 경우 dx, dy 설정
// 하, 우, 좌, 상
int dx[4] = {0, 1, -1, 0};
int dy[4] = {1, 0, 0, -1};
이렇게 설정하면 3 - dir = 반대 방향이 된다.
######################################################################################
- 최대 최소값으로 초기값을 넣어주기 위해서는
    - #include <climits> 라이브러리를 추가하여
    - int max_val = INT_MIN; 이런 식으로 대입해주면 된다.